/**
 * Enhanced SMTP client implementation with multiple auth methods and better error handling
 */

import * as tls from "tls";
import * as net from "net";
import * as fs from "fs";
import * as path from "path";
import * as os from "os";

export class SMTPClient {
    constructor(config) {
        this.host = config.host;
        this.port = config.port;
        this.secure = config.secure;
        this.requireTLS = config.requireTLS || false;
        this.ignoreTLS = config.ignoreTLS || false;
        this.auth = config.auth;
        this.connectionTimeout = config.connectionTimeout || 60000;
        this.greetingTimeout = config.greetingTimeout || 30000;
        this.socketTimeout = config.socketTimeout || 60000;
        this.debug = config.debug || false;
        this.name = config.name || os.hostname();
        this.socket = null;
        this.buffer = "";
        this.capabilities = new Set();
    }

    async connect() {
        return new Promise((resolve, reject) => {
            const timeout = setTimeout(() => {
                this.socket?.destroy();
                reject(new Error(`Connection timeout after ${this.connectionTimeout}ms`));
            }, this.connectionTimeout);

            const onConnect = () => {
                clearTimeout(timeout);
                this.socket.removeListener("error", onError);
                this.socket.setTimeout(this.socketTimeout);
                if (this.debug) console.log(`Connected to ${this.host}:${this.port}`);
                resolve();
            };

            const onError = (err) => {
                clearTimeout(timeout);
                this.socket?.removeListener("connect", onConnect);
                reject(new Error(`Connection failed: ${err.message}`));
            };

            if (this.secure) {
                this.socket = tls.connect({
                    host: this.host,
                    port: this.port,
                    servername: this.host,
                    rejectUnauthorized: !this.ignoreTLS
                });
            } else {
                this.socket = net.connect({ host: this.host, port: this.port });
            }

            this.socket.once("connect", onConnect);
            this.socket.once("error", onError);
            this.socket.setEncoding("utf8");
        });
    }

    async readResponse() {
        return new Promise((resolve, reject) => {
            const onData = (chunk) => {
                this.buffer += chunk;
                const lines = this.buffer.split("\r\n");

                for (let i = 0; i < lines.length - 1; i++) {
                    const line = lines[i];
                    if (line.length >= 3 && line[3] === " ") {
                        this.buffer = lines.slice(i + 1).join("\r\n");
                        this.socket.removeListener("data", onData);
                        this.socket.removeListener("error", onError);
                        resolve(line);
                        return;
                    }
                }
            };

            const onError = (err) => {
                this.socket.removeListener("data", onData);
                reject(err);
            };

            this.socket.on("data", onData);
            this.socket.once("error", onError);
        });
    }

    async sendCommand(command, expectCode = "250") {
        this.socket.write(command + "\r\n");
        const response = await this.readResponse();
        if (!response.startsWith(expectCode)) {
            throw new Error(`SMTP Error: ${response}`);
        }
        return response;
    }

    async authenticate() {
        // Send EHLO and parse capabilities
        const ehloResponse = await this.sendCommand("EHLO " + this.name);
        this.parseCapabilities(ehloResponse);

        // Handle STARTTLS if required
        if (this.requireTLS && !this.secure && this.capabilities.has('STARTTLS')) {
            await this.sendCommand("STARTTLS", "220");
            await this.upgradeToTLS();
            // Re-send EHLO after STARTTLS
            const newEhloResponse = await this.sendCommand("EHLO " + this.name);
            this.parseCapabilities(newEhloResponse);
        }

        // Authenticate based on auth type
        const authType = this.auth.type || 'login';

        switch (authType.toLowerCase()) {
            case 'login':
                await this.authLogin();
                break;
            case 'plain':
                await this.authPlain();
                break;
            case 'oauth2':
                await this.authOAuth2();
                break;
            case 'xoauth2':
                await this.authXOAuth2();
                break;
            default:
                throw new Error(`Unsupported authentication method: ${authType}`);
        }
    }

    parseCapabilities(ehloResponse) {
        // Parse EHLO response to extract server capabilities
        const lines = ehloResponse.split('\n');
        for (const line of lines) {
            const trimmed = line.trim();
            if (trimmed.startsWith('250-') || trimmed.startsWith('250 ')) {
                const capability = trimmed.substring(4).split(' ')[0];
                this.capabilities.add(capability.toUpperCase());
            }
        }
        if (this.debug) console.log('Server capabilities:', Array.from(this.capabilities));
    }

    async upgradeToTLS() {
        return new Promise((resolve, reject) => {
            const secureSocket = tls.connect({
                socket: this.socket,
                servername: this.host,
                rejectUnauthorized: !this.ignoreTLS
            });

            secureSocket.once('secureConnect', () => {
                this.socket = secureSocket;
                this.socket.setEncoding("utf8");
                if (this.debug) console.log('Upgraded to TLS');
                resolve();
            });

            secureSocket.once('error', reject);
        });
    }

    async authLogin() {
        if (!this.capabilities.has('AUTH') && !this.capabilities.has('LOGIN')) {
            throw new Error('Server does not support LOGIN authentication');
        }

        await this.sendCommand("AUTH LOGIN", "334");
        await this.sendCommand(Buffer.from(this.auth.user).toString("base64"), "334");
        await this.sendCommand(Buffer.from(this.auth.pass).toString("base64"), "235");
    }

    async authPlain() {
        if (!this.capabilities.has('AUTH') && !this.capabilities.has('PLAIN')) {
            throw new Error('Server does not support PLAIN authentication');
        }

        const authString = Buffer.from(`\0${this.auth.user}\0${this.auth.pass}`).toString('base64');
        await this.sendCommand(`AUTH PLAIN ${authString}`, "235");
    }

    async authOAuth2() {
        // Simplified OAuth2 implementation
        if (!this.auth.accessToken) {
            throw new Error('OAuth2 access token is required');
        }

        const authString = `user=${this.auth.user}\x01auth=Bearer ${this.auth.accessToken}\x01\x01`;
        const base64Auth = Buffer.from(authString).toString('base64');
        await this.sendCommand(`AUTH OAUTHBEARER ${base64Auth}`, "235");
    }

    async authXOAuth2() {
        if (!this.auth.accessToken) {
            throw new Error('XOAUTH2 access token is required');
        }

        const authString = `user=${this.auth.user}\x01auth=Bearer ${this.auth.accessToken}\x01\x01`;
        const base64Auth = Buffer.from(authString).toString('base64');
        await this.sendCommand(`AUTH XOAUTH2 ${base64Auth}`, "235");
    }

    async sendMail(mailOptions) {
        await this.sendCommand(`MAIL FROM:<${mailOptions.from}>`);

        // Collect all recipients (TO, CC, BCC)
        const allRecipients = [];

        // Add TO recipients
        const toRecipients = Array.isArray(mailOptions.to) ? mailOptions.to : [mailOptions.to];
        allRecipients.push(...toRecipients);

        // Add CC recipients
        if (mailOptions.cc) {
            const ccRecipients = Array.isArray(mailOptions.cc) ? mailOptions.cc : [mailOptions.cc];
            allRecipients.push(...ccRecipients);
        }

        // Add BCC recipients
        if (mailOptions.bcc) {
            const bccRecipients = Array.isArray(mailOptions.bcc) ? mailOptions.bcc : [mailOptions.bcc];
            allRecipients.push(...bccRecipients);
        }

        // Send RCPT TO for all recipients
        for (const recipient of allRecipients) {
            const email = this.extractEmail(recipient.trim());
            await this.sendCommand(`RCPT TO:<${email}>`);
        }

        await this.sendCommand("DATA", "354");

        const messageId = mailOptions.messageId || `<${Date.now()}.${Math.random().toString(36).substr(2, 9)}@${this.host}>`;
        const boundary = `----=_Part_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

        let message = `From: ${mailOptions.fromHeader}\r\n`;
        message += `To: ${toRecipients.join(", ")}\r\n`;

        // Add CC header (but not BCC for privacy)
        if (mailOptions.cc) {
            const ccRecipients = Array.isArray(mailOptions.cc) ? mailOptions.cc : [mailOptions.cc];
            message += `Cc: ${ccRecipients.join(", ")}\r\n`;
        }

        // Add Reply-To if specified
        if (mailOptions.replyTo) {
            message += `Reply-To: ${mailOptions.replyTo}\r\n`;
        }

        message += `Subject: ${mailOptions.subject}\r\n`;
        message += `Message-ID: ${messageId}\r\n`;
        message += `Date: ${mailOptions.date ? mailOptions.date.toUTCString() : new Date().toUTCString()}\r\n`;

        // Add priority header
        if (mailOptions.priority && mailOptions.priority !== 'normal') {
            const priorityMap = { high: '1 (Highest)', low: '5 (Lowest)' };
            message += `X-Priority: ${priorityMap[mailOptions.priority]}\r\n`;
        }

        // Add custom headers
        if (mailOptions.headers) {
            for (const [key, value] of Object.entries(mailOptions.headers)) {
                message += `${key}: ${value}\r\n`;
            }
        }

        message += `MIME-Version: 1.0\r\n`;

        const hasAttachments = mailOptions.attachments && mailOptions.attachments.length > 0;

        if (hasAttachments) {
            message += `Content-Type: multipart/mixed; boundary="${boundary}"\r\n\r\n`;
            message += `--${boundary}\r\n`;
        }

        if (mailOptions.html && mailOptions.text) {
            const altBoundary = `----=_Part_Alt_${Date.now()}`;
            message += `Content-Type: multipart/alternative; boundary="${altBoundary}"\r\n\r\n`;
            message += `--${altBoundary}\r\n`;
            message += `Content-Type: text/plain; charset=utf-8\r\n\r\n`;
            message += `${mailOptions.text}\r\n\r\n`;
            message += `--${altBoundary}\r\n`;
            message += `Content-Type: text/html; charset=utf-8\r\n\r\n`;
            message += `${mailOptions.html}\r\n\r\n`;
            message += `--${altBoundary}--\r\n`;
        } else if (mailOptions.html) {
            message += `Content-Type: text/html; charset=utf-8\r\n\r\n`;
            message += `${mailOptions.html}\r\n`;
        } else if (mailOptions.text) {
            message += `Content-Type: text/plain; charset=utf-8\r\n\r\n`;
            message += `${mailOptions.text}\r\n`;
        }

        if (hasAttachments) {
            for (const attachment of mailOptions.attachments) {
                const fileContent = fs.readFileSync(attachment.path);
                const base64Content = fileContent.toString("base64");
                const filename = attachment.filename || path.basename(attachment.path);

                message += `\r\n--${boundary}\r\n`;
                message += `Content-Type: application/octet-stream; name="${filename}"\r\n`;
                message += `Content-Transfer-Encoding: base64\r\n`;
                message += `Content-Disposition: attachment; filename="${filename}"\r\n\r\n`;

                for (let i = 0; i < base64Content.length; i += 76) {
                    message += base64Content.substring(i, i + 76) + "\r\n";
                }
            }
            message += `--${boundary}--\r\n`;
        }

        message += "\r\n.\r\n";
        this.socket.write(message);

        const response = await this.readResponse();
        if (!response.startsWith("250")) {
            throw new Error(`Failed to send email: ${response}`);
        }

        return messageId;
    }

    extractEmail(emailString) {
        // Extract email from "Name <email@domain.com>" format
        const match = emailString.match(/<([^>]+)>/);
        return match ? match[1] : emailString;
    }

    async quit() {
        try {
            await this.sendCommand("QUIT", "221");
        } catch (e) {
            // Ignore quit errors
        }
        this.socket?.end();
        this.socket?.destroy();
    }
}